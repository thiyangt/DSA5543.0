# Spatial Data Visualisation

## R packages for spatial data analysis

- rgdal

- sp

- rgeos

- raster

- sf

- tmap

- leaflet

- ggmap

- maptools

- gstat

- spatstat

- stars

- geosphere

- RgoogleMaps

- rasterVis

## Geospatial vector data structures

- Point: Individual longitude and latitude of locations

    Eg: Locations, Buildings

- Lines: Two or more vertices or points that are connected

    Eg: Roads, rivers

- Polygons: Three or more vertices and closed

    Eg: Area of a country, state, district
    
## Challenge in Spatial Data Viualisation

Move from 

![](https://media.tenor.com/4A4UHbVtBIIAAAAC/globe-world.gif)

to

```{r, echo=FALSE}
library(ggplot2)
map <- map_data("world")
ggplot(data = map, aes(long, lat, group = group)) + geom_polygon(color = "white") +
  labs(x = "Longitude",
       y = "Latitude") +
  theme(legend.position = "none")
```

How to transform this three dimensional angular system to a two dimensional cartesian system?

Solution: Spatial Projections

## Map Projection

- A projection is about the geometric transformation from 3D to 2D.

- A map projection is a method or mathematical formula to represent the curved surface of the Earth on a flat map.

- It focuses on how the Earth’s surface is “flattened”, which always introduces some distortion in area, shape, distance, or direction.

Examples:

Mercator (preserves direction)

Albers Equal-Area Conic (preserves area)

Goode Homolosine (minimizes distortion globally)


## Types of Map Projections

### Cylindrical Projections

Imagine wrapping a cylinder around the Earth and projecting the surface onto it.

Characteristics:

Meridians and parallels are straight and perpendicular.

Distortion increases away from the equator.

Example:

Mercator Projection – preserves direction, but greatly distorts area near the poles.

### Conical Projections

Imagine wrapping a cone over the Earth, usually touching at one or two standard parallels.

Characteristics:

Parallels appear as arcs; meridians converge toward a point.

Best for mid-latitude regions with an east–west extent.

Example:

Albers Equal-Area Conic – preserves area, commonly used for countries or regions.

### Planar (Azimuthal) Projections

The Earth’s surface is projected onto a flat plane, usually touching at a single point.

Characteristics:

Distortion increases outward from the point of tangency.

Can preserve distance, area, or shape depending on the type.

Example:

Goode Homolosine – minimizes global distortion by combining multiple projection methods.

Visit [here](https://johnedevans.files.wordpress.com/2019/01/map-projections-explained.jpg) to see the visual illustration.



## Example maps

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
#https://r-spatial.org/r/2018/10/25/ggplot2-sf.html
world <- ne_countries(scale = "medium", returnclass = "sf")
p1 <- ggplot(data = world)+
  geom_sf()+
  labs(title = 'ESRI:54030: Robinson projection')+             theme(plot.title = element_text(face = "bold"))+
  coord_sf(crs = st_crs("ESRI:54030"))

```

```{r, echo=FALSE, warning=FALSE, message=FALSE,fig.width=20, fig.height=15}
p2 <- ggplot(data = world)+
  geom_sf()+
  labs(title = 'ESRI:54009: Mollweide projection')+             theme(plot.title = element_text(face = "bold"))+
  coord_sf(crs = st_crs("ESRI:54009"))

p3 <- ggplot(data = world)+
  geom_sf()+
  labs(title = 'ESRI:54002: Equidistant cylindrical projection')+             theme(plot.title = element_text(face = "bold"))+
  coord_sf(crs = st_crs("ESRI:54002"))

p4 <- ggplot(data = world)+
  geom_sf()+
  labs(title = 'ESRI:54008: Sinusoidal projection')+             theme(plot.title = element_text(face = "bold"))+
  coord_sf(crs = st_crs("ESRI:54008"))

 
```

```{r}
p1
p2
p3
p4
```
## Why Multiple Map Projection Types Exist

The Earth is round, but maps are flat. Because no flat map can perfectly preserve all properties of the globe, every projection introduces some distortion. Different projections are therefore designed to preserve certain properties depending on the map’s purpose.

### Key Reasons for Multiple Projection Types

1. Different Types of Distortion

Shape (conformal) – keeps angles and shapes correct (e.g., Mercator).

Area (equal-area / equivalent) – keeps relative sizes correct (e.g., Albers Equal-Area Conic).

Distance (equidistant) – preserves distances from a point or along certain lines (e.g., Azimuthal Equidistant).

Direction (azimuthal / navigational) – preserves angles and compass bearings (e.g., Mercator for navigation).

2. Geographical Focus

Some projections are better for global maps, others for regional or local maps.

Example: Conical projections work well for mid-latitude countries, while planar projections work for polar regions.

3. Practical Applications

Navigation – need accurate direction → Mercator.

Thematic / statistical maps – need accurate area → Albers Equal-Area.

Minimizing overall distortion – Goode Homolosine for global thematic maps.


```{r, echo=FALSE, eval=FALSE}
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)

# Load world map
world <- ne_countries(scale = "medium", returnclass = "sf")

# 1. Cylindrical (Mercator)
p1 <- ggplot(data = world) +
  geom_sf() +
  labs(title = "Mercator Projection (EPSG:3395)") +
  theme(plot.title = element_text(face = "bold")) +
  coord_sf(crs = st_crs(3395))  # Mercator

# 2. Conical (Albers Equal-Area Conic)
p2 <- ggplot(data = world) +
  geom_sf() +
  labs(title = "Albers Equal-Area Conic (ESRI:102003)") +
  theme(plot.title = element_text(face = "bold")) +
  coord_sf(crs = st_crs("ESRI:102003"))  # Albers Equal-Area Conic

# 3. Planar (Goode Homolosine / Sinusoidal)
p3 <- ggplot(data = world) +
  geom_sf() +
  labs(title = "Goode Homolosine / Sinusoidal (ESRI:54008)") +
  theme(plot.title = element_text(face = "bold")) +
  coord_sf(crs = st_crs("ESRI:54008"))  # Sinusoidal

# Plot maps
library(gridExtra)
grid.arrange(p1, p2, p3, nrow = 3)

```

## Quick Comparison Table

In-class

## Coordinate Reference System (CRS)

A CRS is a complete spatial reference framework that defines:

- How coordinates relate to the Earth (datum) 

    A datum defines the mathematical Earth model and reference point for coordinates, ensuring that latitude, longitude, and height correspond to real positions on the Earth.)

- The map projection used (if any)

## What is a Datum?

A datum is a mathematical model of the Earth that defines:

The size and shape of the Earth (ellipsoid or spheroid)

The origin and orientation of the coordinate system (where latitude 0°, longitude 0° are defined)

In short, a datum tells us where "zero" is and how the coordinates are measured on the Earth’s surface.

## Why is a Datum Important?

Different datums model the Earth slightly differently, so the same latitude/longitude may correspond to different locations depending on the datum.

Example:

WGS84 → used by GPS

NAD83 → used in North America

A coordinate of 40°N, 75°W will be slightly different on WGS84 vs NAD83 because the reference ellipsoid is slightly shifted.

## Projection vs CRS

- Projection = method to flatten the Earth

- CRS = full system that defines the Earth model + projection + coordinate rules

## Shapefile

A shapefile is a popular geospatial vector data format used to store geographic features like points, lines, and polygons, along with their attributes. It’s commonly used in GIS (Geographic Information Systems) and mapping software, including R (sf or rgdal packages).

A shapefile actually consists of several files that work together. The main ones are:

| File Extension | Purpose |
|----------------|---------|
| .shp           | Geometry of features (points, lines, polygons) |
| .shx           | Shape index (helps software find features quickly) |
| .dbf           | Attribute data (like a spreadsheet) |
| .prj           | Projection information (coordinate reference system) |
| .cpg           | Encoding of text attributes (optional) |


## R Example 1

```{r}
library(sf)
library(rnaturalearth)

# Read shapefile
world <- ne_countries(scale = "medium", returnclass = "sf")
head(world)

# Check CRS
st_crs(world)
#> CRS: EPSG:4326 (WGS84) → unprojected lat/lon in degrees

# Project to UTM
world_utm <- st_transform(world, crs = 32633)
#> CRS: EPSG:32633 → projected in meters

```

## R Example 2

```{r, message=FALSE, warning=FALSE}
# install.packages("devtools")
devtools::install_github("thiyangt/ceylon")
library(ceylon)
library(tidyverse)
library(sp)
library(viridis)
```

```{r}
data(sf_sl_0)
class(sf_sl_0)
# work with spatial data; sp package will load with rgdal.
library(rgdal)
# for metadata/attributes- vectors or rasters
library(raster)
crs(sf_sl_0)


```



```{r}
sf_sl_0
```

or

```{r}
st_crs(sf_sl_0)
```

Visualizing using shapefiles: map of Sri Lanka

```{r}
ggplot(sf_sl_0) +
  geom_sf()
```



```{r}
ggplot(sf_sl_0) +
  geom_sf(fill='beige') +
theme_minimal()
```



```{r}
library(knitr)
sf_sl_0 %>% kable()
```

## Exercise

1. Draw district and province maps

data:

```r
province
district
```

2. Guess the output.

```{r,eval=FALSE}
ggplot() +
  geom_sf(data=province, lwd=2, col="black") + 
  geom_sf(data=district, linetype=21, col="red")
```


3. Colour provinces according to the population.

## Annotations


```{r,eval=FALSE}
ggplot(sf_sl_0) +
  geom_sf(fill='beige') +
ggspatial::annotation_north_arrow(location = "br")+
  ggspatial::annotation_scale(location = "bl")
```



```{r,echo=FALSE}
ggplot(sf_sl_0) +
  geom_sf(fill='beige') +
ggspatial::annotation_north_arrow(location = "br")+
  ggspatial::annotation_scale(location = "bl")
```

## Spatial Data Wrangling

1. Convert regular data frame to sf

```{r}
library(sf)
library(dplyr)

# Example data frame: cities with lat/lon
cities <- data.frame(
  name = c("New York", "London", "Tokyo"),
  lon = c(-74.0060, -0.1276, 139.6917),
  lat = c(40.7128, 51.5074, 35.6895)
)

# Convert to sf object
cities_sf <- st_as_sf(cities, coords = c("lon", "lat"), crs = 4326)

```

```{r}
st_crs(cities_sf)
#> EPSG:4326 (WGS84)

```

2. Transforming coordinates

```{r}
# Transform to UTM (meters)
cities_utm <- st_transform(cities_sf, crs = 32618)  # UTM zone 18N

st_crs(cities_utm)
#> EPSG:32618 → coordinates in meters
```

```{r}
# Original coordinates (degrees)
cities_sf

# Transformed coordinates (meters)
cities_utm
```


## Two types of maps 

1. Simple feature map

2. Polygon maps

## Simple feature map

```{r}
ggplot(sf_sl_0) +
  geom_sf() +
  coord_sf()
```

```{r}
ggplot(sf_sl_0) +
  geom_sf() +
  coord_sf(crs = st_crs(3577))
```

## Polygon map

Example 1

```{r}
library(ggplot2)
library(sf)

# Create a simple polygon (square) as sf object
coords <- matrix(c(
  0, 0,
  0, 1,
  1, 1,
  1, 0,
  0, 0  # close the polygon
), ncol = 2, byrow = TRUE)

polygon_sf <- st_sf(
  geometry = st_sfc(st_polygon(list(coords)))
)
polygon_sf

# Extract coordinates for geom_point
polygon_points <- st_coordinates(polygon_sf)
polygon_points

# Convert to data frame
polygon_df <- as.data.frame(polygon_points)
head(polygon_df)

# Plot using geom_point
ggplot(polygon_df, aes(x = X, y = Y)) +
  geom_point(color = "blue", size = 3) +
  coord_fixed() +
  labs(title = "Polygon represented by points")

```


```{r}
library(ceylon)
data(sf_sl_0)
sf_sl_0
# Convert to data frame
polygon_df_sl <- as.data.frame(sf_sl_0)
polygon_df_sl


```

Example 2

```{r}
# devtools::install_github("UrbanInstitute/urbnmapr")
library(tidyverse)
library(magrittr)
library(urbnmapr)
library(usmap) # to obtain population data
library(ggthemes)
library(scales)
library(geofacet)

```



```{r}
statepop1 <- statepop %>% rename(state_name = full)
head(statepop1)
statepop2 <- full_join(statepop1, states, by = "state_name")
head(statepop2)
```


```{r}
ggplot() + 
  geom_point(data = statepop2, mapping = aes(x = long, y = lat, group = group), fill = "grey", color = "black") 

```


```{r}
ggplot() + 
  geom_polygon(data = statepop2, mapping = aes(x = long, y = lat, group = group),fill = "grey", color = "black") 
```


Example 3

```{r}
mi_counties <- map_data("county", "michigan") %>% 
  select(lon = long, lat, group, id = subregion)
head(mi_counties)
```

Plot: in class

## rnaturalearth 

rnaturalearth is an R package that provides ready-to-use maps of the world, countries, and regions as sf (spatial) or data frames. It’s a super convenient way to get geographic data without downloading shapefiles manually.

Example 1

```{r}
library(ggplot2)
library(dplyr)
library(rnaturalearth)
library(rnaturalearthdata)
# Get Sri Lanka admin-1 regions (provinces)
sri_lanka <- ne_states(country = "Sri Lanka", returnclass = "sf")

# Check the first few rows
head(sri_lanka)

```

Example 2

```{r}
library(rnaturalearth)
library(sf)
library(ggplot2)

# Get world countries as sf object
world <- ne_countries(scale = "medium", returnclass = "sf")

# Plot the map
ggplot(world) +
  geom_sf(fill = "lightblue", color = "black") +
  labs(title = "World Map")

```


## Practical

1. Mark following locations on the map

```{r}
oz_capitals <- tibble::tribble( 
  ~city,           ~lat,     ~lon,
  "Sydney",    -33.8688, 151.2093,  
  "Melbourne", -37.8136, 144.9631, 
  "Brisbane",  -27.4698, 153.0251, 
  "Adelaide",  -34.9285, 138.6007, 
  "Perth",     -31.9505, 115.8605, 
  "Hobart",    -42.8821, 147.3272, 
  "Canberra",  -35.2809, 149.1300, 
  "Darwin",    -12.4634, 130.8456, 
)
```

Help:

```{r}
library(ozmaps)
library(sf)
oz_states <- ozmaps::ozmap_states
oz_states
```

2. Projecting your data

```{r}
library(sf)
library(ggplot2)
# devtools::install_github("hrbrmstr/albersusa")
library(albersusa)
crs_use = "+proj=laea +lat_0=30 +lon_0=-95"

d_points = data.frame(long = c(-110, -103, -84), 
                      lat  = c(45, 40, 41))
```

